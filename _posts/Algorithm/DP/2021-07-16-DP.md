---
layout: posts
title: Dynamic Programming
comments: true
author_profile: true
use_math: true
categories: [Algorithm]
---

메모리 공간을 약간 더 사용해서 연산 속도를 증가시킨다.

## 피보나치 수열
다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시.
이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열.

### 점화식
인접한 항들 사이의 관계식을 의미.
예를 들어, 수열 $\{a_n\}$이 있을 때 수열에서의 각 항을 $a_n$이라고 부른다고 가정.
피보나치의 수열의 점화식은 다음과 같이 표현.
$a_{n+2}=f(a_{n+1}, a_n)=a_{n+1}+a_n$
이러한 점화식을 인접 3항간 점화식이라고 부른다.
최종적으로 피보나치 수열을 나타낼 때에는 다음과 같이 정의할 수 있다.
$a_n=a_{n-1}+a_{n-2},a_1=1,a_2=1$
재귀 함수를 사용해서 점화식을 프로그래밍할 경우 심각한 문제가 생길 수 있다.
$f(n)$ 함수에 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다. 빅오 표기법을 사용할 경우 $O(2^N)$의 지수 시간이 소요된다.

## DP를 사용하는 조건
1. 큰 문제를 작은 문제로 나눌 수 있다
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

## Memoization 기법
한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미. 값을 저장하는 방법이므로 Caching이라고도 한다. DP를 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 $O(N)$이다. 

### Top-Down 방식
재귀 함수를 이용하여 작성. 큰 문제를 해결하기 위해서 작은 문제를 호출.
하향식.
```python
d = [0] * 100
def pibo(x):
	print('f('+str(x)+')', end=' ')
	if x == 1 or x == 2:
		return 1
	if d[x] != 0:
		return d[x]
	d[x] = pibo(x-1) + pibo(x-2)
	return d[x]
pibo(6)
```
### Bottom-Up 방식
단순히 반복문을 이용하여 작성. 작은 문제부터 차근차근 답을 도출.
상향식.
```python
d = [0]*100
d[1] = 1
d[2] = 1
n = 99
for i in range(3, n+1):
	d[i] = d[i-1] + d[i-2]

print(d[n])
```
DP의 전형적인 형태는 Bottom-Up 방식이다.
보텀업 방식에서 사용되는 결과 저장용 리스트는 DP 테이블이라고 부르며, **Memoization은 Top-Down 방식에 국한되어 사용하는 표현**이다.
상황에 따라서 사전 자료형을 이용할 수도 있는데, 연속적이지 않은 경우에 사용할 수 있다. 

## 코딩 테스트에서의 DP
대체로 간단한 형태로 출제된다.
1. 문제를 푸는 첫 단계는 유형 파악 !!
	완전 탐색 알고리즘으로 접근했을 때 시간이 오래 걸리면 DP를 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인 !!
2. 단순하게 재귀 함수로 비효율적인 프로그램을 작성한 뒤에 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면 메모이제이션 적용해서 개선 !!
3. 가능하다면 보텀업 방식으로 구현하자 !! 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있음 !! 이 경우, sys 라이브러리에 포함되어 있는 setrecursionlimit( ) 함수를 호출하여 재귀 제한을 완화.
